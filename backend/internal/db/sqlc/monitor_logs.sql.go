// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: monitor_logs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMonitorLog = `-- name: CreateMonitorLog :one
INSERT INTO monitor_logs (
    monitor_id, status_code, response_time, 
    dns_ok, ssl_ok, content_ok, screenshot_url
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, monitor_id, status_code, response_time, dns_ok, ssl_ok, content_ok, screenshot_url, checked_at
`

type CreateMonitorLogParams struct {
	MonitorID     pgtype.Int4   `json:"monitor_id"`
	StatusCode    pgtype.Int4   `json:"status_code"`
	ResponseTime  pgtype.Float8 `json:"response_time"`
	DnsOk         pgtype.Bool   `json:"dns_ok"`
	SslOk         pgtype.Bool   `json:"ssl_ok"`
	ContentOk     pgtype.Bool   `json:"content_ok"`
	ScreenshotUrl pgtype.Text   `json:"screenshot_url"`
}

func (q *Queries) CreateMonitorLog(ctx context.Context, arg CreateMonitorLogParams) (MonitorLog, error) {
	row := q.db.QueryRow(ctx, createMonitorLog,
		arg.MonitorID,
		arg.StatusCode,
		arg.ResponseTime,
		arg.DnsOk,
		arg.SslOk,
		arg.ContentOk,
		arg.ScreenshotUrl,
	)
	var i MonitorLog
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.StatusCode,
		&i.ResponseTime,
		&i.DnsOk,
		&i.SslOk,
		&i.ContentOk,
		&i.ScreenshotUrl,
		&i.CheckedAt,
	)
	return i, err
}

const getMonitorLogs = `-- name: GetMonitorLogs :many
SELECT id, monitor_id, status_code, response_time, dns_ok, ssl_ok, content_ok, screenshot_url, checked_at FROM monitor_logs 
WHERE monitor_id = $1 
ORDER BY checked_at DESC 
LIMIT $2
`

type GetMonitorLogsParams struct {
	MonitorID pgtype.Int4 `json:"monitor_id"`
	Limit     int32       `json:"limit"`
}

func (q *Queries) GetMonitorLogs(ctx context.Context, arg GetMonitorLogsParams) ([]MonitorLog, error) {
	rows, err := q.db.Query(ctx, getMonitorLogs, arg.MonitorID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MonitorLog{}
	for rows.Next() {
		var i MonitorLog
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.StatusCode,
			&i.ResponseTime,
			&i.DnsOk,
			&i.SslOk,
			&i.ContentOk,
			&i.ScreenshotUrl,
			&i.CheckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonitorLogsByTimeRange = `-- name: GetMonitorLogsByTimeRange :many
SELECT id, monitor_id, status_code, response_time, dns_ok, ssl_ok, content_ok, screenshot_url, checked_at FROM monitor_logs 
WHERE monitor_id = $1 
AND checked_at BETWEEN $2 AND $3 
ORDER BY checked_at DESC
`

type GetMonitorLogsByTimeRangeParams struct {
	MonitorID   pgtype.Int4      `json:"monitor_id"`
	CheckedAt   pgtype.Timestamp `json:"checked_at"`
	CheckedAt_2 pgtype.Timestamp `json:"checked_at_2"`
}

func (q *Queries) GetMonitorLogsByTimeRange(ctx context.Context, arg GetMonitorLogsByTimeRangeParams) ([]MonitorLog, error) {
	rows, err := q.db.Query(ctx, getMonitorLogsByTimeRange, arg.MonitorID, arg.CheckedAt, arg.CheckedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MonitorLog{}
	for rows.Next() {
		var i MonitorLog
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.StatusCode,
			&i.ResponseTime,
			&i.DnsOk,
			&i.SslOk,
			&i.ContentOk,
			&i.ScreenshotUrl,
			&i.CheckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentMonitorStatus = `-- name: GetRecentMonitorStatus :one
SELECT status_code, response_time, checked_at 
FROM monitor_logs 
WHERE monitor_id = $1 
ORDER BY checked_at DESC 
LIMIT 1
`

type GetRecentMonitorStatusRow struct {
	StatusCode   pgtype.Int4      `json:"status_code"`
	ResponseTime pgtype.Float8    `json:"response_time"`
	CheckedAt    pgtype.Timestamp `json:"checked_at"`
}

func (q *Queries) GetRecentMonitorStatus(ctx context.Context, monitorID pgtype.Int4) (GetRecentMonitorStatusRow, error) {
	row := q.db.QueryRow(ctx, getRecentMonitorStatus, monitorID)
	var i GetRecentMonitorStatusRow
	err := row.Scan(&i.StatusCode, &i.ResponseTime, &i.CheckedAt)
	return i, err
}
