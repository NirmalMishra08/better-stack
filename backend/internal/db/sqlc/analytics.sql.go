// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: analytics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const calculateUptimePercentage = `-- name: CalculateUptimePercentage :one
SELECT 
    COUNT(*) as total_checks,
    SUM(CASE WHEN status_code BETWEEN 200 AND 399 THEN 1 ELSE 0 END) as successful_checks,
    ROUND(
        (SUM(CASE WHEN status_code BETWEEN 200 AND 399 THEN 1 ELSE 0 END) * 100.0 / COUNT(*))::numeric, 
    2) as uptime_percentage
FROM monitor_logs 
WHERE monitor_id = $1 
AND checked_at >= $2
`

type CalculateUptimePercentageParams struct {
	MonitorID pgtype.Int4      `json:"monitor_id"`
	CheckedAt pgtype.Timestamp `json:"checked_at"`
}

type CalculateUptimePercentageRow struct {
	TotalChecks      int64          `json:"total_checks"`
	SuccessfulChecks int64          `json:"successful_checks"`
	UptimePercentage pgtype.Numeric `json:"uptime_percentage"`
}

func (q *Queries) CalculateUptimePercentage(ctx context.Context, arg CalculateUptimePercentageParams) (CalculateUptimePercentageRow, error) {
	row := q.db.QueryRow(ctx, calculateUptimePercentage, arg.MonitorID, arg.CheckedAt)
	var i CalculateUptimePercentageRow
	err := row.Scan(&i.TotalChecks, &i.SuccessfulChecks, &i.UptimePercentage)
	return i, err
}

const createOrUpdateAnalytics = `-- name: CreateOrUpdateAnalytics :one
INSERT INTO analytics (
    monitor_id, uptime_percentage, avg_response_time, last_24h_downtime
) VALUES ($1, $2, $3, $4)
ON CONFLICT (monitor_id) 
DO UPDATE SET 
    uptime_percentage = EXCLUDED.uptime_percentage,
    avg_response_time = EXCLUDED.avg_response_time,
    last_24h_downtime = EXCLUDED.last_24h_downtime,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, monitor_id, uptime_percentage, avg_response_time, last_24h_downtime, updated_at
`

type CreateOrUpdateAnalyticsParams struct {
	MonitorID        pgtype.Int4   `json:"monitor_id"`
	UptimePercentage pgtype.Float8 `json:"uptime_percentage"`
	AvgResponseTime  pgtype.Float8 `json:"avg_response_time"`
	Last24hDowntime  pgtype.Int4   `json:"last_24h_downtime"`
}

func (q *Queries) CreateOrUpdateAnalytics(ctx context.Context, arg CreateOrUpdateAnalyticsParams) (Analytic, error) {
	row := q.db.QueryRow(ctx, createOrUpdateAnalytics,
		arg.MonitorID,
		arg.UptimePercentage,
		arg.AvgResponseTime,
		arg.Last24hDowntime,
	)
	var i Analytic
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.UptimePercentage,
		&i.AvgResponseTime,
		&i.Last24hDowntime,
		&i.UpdatedAt,
	)
	return i, err
}

const getAnalytics = `-- name: GetAnalytics :one
SELECT id, monitor_id, uptime_percentage, avg_response_time, last_24h_downtime, updated_at FROM analytics 
WHERE monitor_id = $1
`

func (q *Queries) GetAnalytics(ctx context.Context, monitorID pgtype.Int4) (Analytic, error) {
	row := q.db.QueryRow(ctx, getAnalytics, monitorID)
	var i Analytic
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.UptimePercentage,
		&i.AvgResponseTime,
		&i.Last24hDowntime,
		&i.UpdatedAt,
	)
	return i, err
}

const getAverageResponseTime = `-- name: GetAverageResponseTime :one
SELECT ROUND(AVG(response_time)::numeric, 2) as avg_response_time
FROM monitor_logs 
WHERE monitor_id = $1 
AND checked_at >= $2 
AND response_time IS NOT NULL
`

type GetAverageResponseTimeParams struct {
	MonitorID pgtype.Int4      `json:"monitor_id"`
	CheckedAt pgtype.Timestamp `json:"checked_at"`
}

func (q *Queries) GetAverageResponseTime(ctx context.Context, arg GetAverageResponseTimeParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getAverageResponseTime, arg.MonitorID, arg.CheckedAt)
	var avg_response_time pgtype.Numeric
	err := row.Scan(&avg_response_time)
	return avg_response_time, err
}
